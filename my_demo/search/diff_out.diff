diff --git a/my_demo/run_with_search.py b/my_demo/run_with_search.py
index f3c19e1..023d1c2 100644
--- a/my_demo/run_with_search.py
+++ b/my_demo/run_with_search.py
@@ -88,9 +88,15 @@ def batch_main():
     print("ALL DONE")
 
 if __name__ == "__main__":
-    profiler = Profiler()
-    profiler.start()
+    # profiler = Profiler()
+    # profiler.start()
     # batch_main()
+    import time
+    start_time = time.time()
     single_main()
-    profiler.stop()
-    profiler.write_html("/Users/lvxiangdong/Desktop/work/some_project/CRC25/my_demo/output/visual/profiler.html",show_all=True)
+    elapsed = int(time.time() - start_time)
+    minutes = elapsed // 60
+    seconds = elapsed % 60
+    print(f"tocal cost ({minutes}分{seconds}秒")
+    # profiler.stop()
+    # profiler.write_html("/Users/lvxiangdong/Desktop/work/some_project/CRC25/my_demo/output/visual/profiler.html",show_all=True)
diff --git a/my_demo/search/saturated_search/MoveData.py b/my_demo/search/saturated_search/MoveData.py
new file mode 100644
index 0000000..6d6ddf0
--- /dev/null
+++ b/my_demo/search/saturated_search/MoveData.py
@@ -0,0 +1,38 @@
+# encoding:utf-8
+"""
+@email  :    xiangdong.lv@geekplus.com
+@auther :    XiangDongLv
+@time   :    2025/6/28 09:47
+@project:    CRC25
+"""
+
+
+class MoveData:
+    def __init__(self, arc, modify_tag, operator_type):
+        self.arc = arc
+        self.modify_tag = modify_tag
+        self.operator_type = {operator_type}
+
+    @property
+    def sort_key(self):
+        """返回用于排序的元组"""
+        return (self.arc, self.modify_tag)
+
+    def __hash__(self):
+        return hash((self.arc, self.modify_tag))
+
+    def __eq__(self, other):
+        if not isinstance(other, MoveData):
+            return False
+        return self.sort_key == other.sort_key
+
+    def __lt__(self, other):
+        if not isinstance(other, MoveData):
+            return NotImplemented
+        return self.sort_key < other.sort_key
+
+    def __str__(self):
+        # 千万别改 problemNode用他做hash
+        return f"{self.arc},{self.modify_tag.name}"
+
+    __repr__ = __str__
diff --git a/my_demo/search/saturated_search/Operator.py b/my_demo/search/saturated_search/Operator.py
index bf74e35..ebf3c63 100644
--- a/my_demo/search/saturated_search/Operator.py
+++ b/my_demo/search/saturated_search/Operator.py
@@ -13,16 +13,18 @@ import math
 from collections import defaultdict
 from typing import List
 import random
+from my_demo.search.saturated_search.MoveData import MoveData
 
-def do_foil_must_be_feasible(root_solver) -> List[tuple]:
-    modified_arc_list = []
+
+def do_foil_must_be_feasible(root_solver) -> List[MoveData]:
+    modified_arc_list = dict()
     for arc in root_solver.data_holder.foil_must_feasible_arcs:
-        modified_arc_list.append((arc, ArcModifyTag.TO_FE))
+        add_one_move(modified_arc_list, MoveData(arc, ArcModifyTag.TO_FE, 'foil_must_fe'))
 
-    return modified_arc_list
+    return list(modified_arc_list.values())
 
 
-def generate_multi_modify_arc_by_graph_feature(solver,info, G, df_path_fact,org_bc_dict=None) -> List[tuple]:
+def generate_multi_modify_arc_by_graph_feature(solver, info, G, df_path_fact, org_bc_dict=None) -> List[MoveData]:
     """
     Args:
         father_problem:
@@ -65,23 +67,30 @@ def generate_multi_modify_arc_by_graph_feature(solver,info, G, df_path_fact,org_
             max_alt_ratio = alt_ratio_score
             max_alt_ratio_arc = arc_id
 
-    result_set = set()
+    result_set = dict()
     if max_node_deg_arc is not None:
-        result_set.add((max_node_deg_arc, ArcModifyTag.TO_INFE))
+        add_one_move(result_set, MoveData(max_node_deg_arc, ArcModifyTag.TO_INFE, 'deg'))
     if max_edge_bc_arc is not None:
-        result_set.add((max_edge_bc_arc, ArcModifyTag.TO_INFE))
+        add_one_move(result_set, MoveData(max_edge_bc_arc, ArcModifyTag.TO_INFE, 'bc'))
     if max_alt_ratio_arc is not None:
-        result_set.add((max_alt_ratio_arc, ArcModifyTag.TO_INFE))
+        add_one_move(result_set, MoveData(max_alt_ratio_arc, ArcModifyTag.TO_INFE, 'alt_ratio'))
 
     fact_id_route = info['fact_sub_path']
-    fork = (fact_id_route[0],fact_id_route[1])
-    merge = (fact_id_route[-2],fact_id_route[-1])
+    fork = (fact_id_route[0], fact_id_route[1])
+    merge = (fact_id_route[-2], fact_id_route[-1])
 
     random_node = random.choice([fork, merge])
-    result_set.add((random_node, ArcModifyTag.TO_INFE))
+    add_one_move(result_set, MoveData(random_node, ArcModifyTag.TO_INFE, 'fork_merge'))
 
     # todo 可以再加一个 lp解出来的候选集
-    return result_set
+    return list(result_set.values())
+
+
+def add_one_move(result_dict, move_data):
+    if move_data in result_dict:
+        result_dict[move_data].operator_type.update(move_data.operator_type)
+    else:
+        result_dict[move_data] = move_data
 
 
 def calculate_alt_ratio(u, v, G, row, weight='dijkstra'):
diff --git a/my_demo/search/saturated_search/ProblemNode.py b/my_demo/search/saturated_search/ProblemNode.py
index 68dc1e7..f00dd8a 100644
--- a/my_demo/search/saturated_search/ProblemNode.py
+++ b/my_demo/search/saturated_search/ProblemNode.py
@@ -13,6 +13,7 @@ from geopandas import GeoDataFrame
 import pandas as pd
 import networkx as nx
 from my_demo.search.DataHolder import DataHolder
+from my_demo.search.saturated_search.MoveData import MoveData
 from utils.dataparser import handle_weight_with_recovery, create_network_graph
 import shapely.ops as so
 import shapely.geometry as sg
@@ -24,11 +25,14 @@ from utils.common_utils import correct_arc_direction
 from my_demo.visual import visual_sub_problem, visual_map_foil_modded
 from typing import List
 from my_demo.search.ArcModifyTag import ArcModifyTag
+from collections import defaultdict
+from my_demo.search.saturated_search.Operator import add_one_move
 
 
 class ProblemNode:
 
-    def __init__(self, solver, info_tuple, modified_arc_list: List[tuple], map_df, map_graph, master, idx_gen, level):
+    def __init__(self, solver, info_tuple, modified_move_list: List[MoveData], map_df, map_graph, master, idx_gen,
+                 level):
         self.idx_gen = idx_gen
         self.idx = next(idx_gen)
         self.level = level
@@ -46,26 +50,43 @@ class ProblemNode:
 
         self.map_df = deepcopy(map_df)
         # todo 暂时没操作图 先不deepcopy
+
+        self.master = master
+
         self.map_graph = map_graph
         if master:
-            self.inherit = [] + modified_arc_list + master.inherit
+            # 用来分析 哪个算子生效多的 #todo 可能影响效率后面需要删除
+            self.inherit_for_visual = deepcopy(master.inherit_for_visual)
+
+            # 用来hash 认为操作一致的
+            self.inherit = [] + master.inherit
+
         else:
-            self.inherit = [] + modified_arc_list
+            # 初始化嵌套字典结构
+            self.inherit_for_visual = dict()
+            self.inherit = []
 
-        self.inherit = sorted(set(self.inherit))
+            # 添加修改记录
+        for move in modified_move_list:
+            add_one_move(self.inherit_for_visual, move)
 
-        self.modified_arc_list = modified_arc_list
+            self.inherit.append(move)
 
-        self.master = master
+        self.modified_move_list = modified_move_list
+
+        self.inherit = sorted(set(self.inherit))
 
         self.df_path_best: GeoDataFrame = None
         self.df_path_foil = self.org_solver.df_path_foil
         self.graph_error = 0
         self.route_error = 0
 
+        self.move_str = None
+
     def apply_modified_arc(self):
         # todo 可以改成操作graph
-        for (i, j), modify_tag in self.modified_arc_list:
+        for move_data in self.modified_move_list:
+            (i, j), modify_tag, name = move_data.arc, move_data.modify_tag, move_data.operator_type
             modified_row = self.org_solver.modify_df_arc_with_attr(i, j, modify_tag)
             solution_row = self.org_solver.current_solution_map.loc[modified_row.name]
             modified_row['modified'] = modified_row['modified'] + solution_row['modified']
@@ -104,7 +125,6 @@ class ProblemNode:
         return (self.route_error, self.graph_error) < (other.route_error, other.graph_error)
 
     def __hash__(self):
-        # 用fork, merge, modified_arc_list的字符串表示做hash
         return hash(str(self.inherit))
 
     def __eq__(self, other):
@@ -113,10 +133,21 @@ class ProblemNode:
         return str(self.inherit) == str(other.inherit)
 
     def __str__(self):
-        return f"【{self.idx},{self.level}:r:{self.route_error}g:{self.graph_error}】#【{self.fork}#{self.merge}#{self.modified_arc_list}】"
+        return f"【{self.idx},{self.level}:r:{self.route_error}g:{self.graph_error}】#【{self.fork}#{self.merge}#{self.visual_move_data()}】"
 
     def __repr__(self):
         return self.__str__()
 
+    def visual_move_data(self) -> str:
+        if self.move_str is not None:
+            return self.move_str
+
+        return_str = ""
+        for move in self.modified_move_list:
+            return_str += f"{move.arc},{move.modify_tag.name},{move.operator_type}"
+
+        self.move_str = f"【{return_str}】"
+        return self.move_str
+
     def better_than_other(self, other):
         return (self.route_error, self.graph_error) < (other.route_error, other.graph_error)
diff --git a/my_demo/search/saturated_search/SearchSolverSaturated.py b/my_demo/search/saturated_search/SearchSolverSaturated.py
index 09dff00..b9b20b5 100644
--- a/my_demo/search/saturated_search/SearchSolverSaturated.py
+++ b/my_demo/search/saturated_search/SearchSolverSaturated.py
@@ -101,11 +101,10 @@ class SearchSolverSaturated(SearchSolver):
             df_path_fact = self.generate_sub_fact(info)
             modify_result_set = generate_multi_modify_arc_by_graph_feature(self, info, problem.new_graph, df_path_fact,
                                                                            org_bc_dict)
-
             print(problem)
-            for modify_arc in modify_result_set:
+            for move in modify_result_set:
                 # todo 这里不可能不命中，至少起点和终点是一样的
-                sub_problem = ProblemNode(self, info, [modify_arc], problem.map_df, problem.new_graph, problem,
+                sub_problem = ProblemNode(self, info, [move], problem.map_df, problem.new_graph, problem,
                                           problem.idx_gen, problem.level + 1)
                 if sub_problem in closed_set:
                     continue
@@ -133,6 +132,6 @@ class SearchSolverSaturated(SearchSolver):
 
     def process_solution_from_model(self):
         self.current_solution_map = self.best_leaf_node.map_df
-
+        print(self.best_leaf_node.inherit_for_visual)
         self.get_best_route_df_from_solution()
         self.calc_error()
